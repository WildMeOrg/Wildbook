-- we need this to be done to our db first by user 'postgres':  create extension "uuid-ossp";
-- if that didnt work, we may need to install this first:  apt-get install postgresql-contrib-9.5



ALTER TABLE "MARKEDINDIVIDUAL" ADD COLUMN "LEGACYINDIVIDUALID" VARCHAR(100) UNIQUE;
ALTER TABLE "MARKEDINDIVIDUAL" ALTER COLUMN "INDIVIDUALID" SET DEFAULT uuid_generate_v4();

-- now we "store" legacy values in LEGACYINDIVIDUALID
UPDATE "MARKEDINDIVIDUAL" SET "LEGACYINDIVIDUALID" = "INDIVIDUALID";

-- this allows us to alter individualid primary key on markedindividual
BEGIN;
ALTER TABLE "MARKEDINDIVIDUAL_ENCOUNTERS" DROP CONSTRAINT "MARKEDINDIVIDUAL_ENCOUNTERS_FK1";
ALTER TABLE "MARKEDINDIVIDUAL_ENCOUNTERS" ADD CONSTRAINT "MARKEDINDIVIDUAL_ENCOUNTERS_FK1" FOREIGN KEY ("INDIVIDUALID_OID") REFERENCES "MARKEDINDIVIDUAL"("INDIVIDUALID") ON UPDATE CASCADE DEFERRABLE INITIALLY DEFERRED;
END;

-- this table seems to only appear on some (ancient?) wildbooks... i think the functionality is gone, so we dont
--  do any other cleanup of id-mapping etc here.  dont worry if you get an error about this
ALTER TABLE "MARKEDINDIVIDUAL_UNIDENTIFIABLEENCOUNTERS" DROP CONSTRAINT "MARKEDINDIVIDUAL_UNIDENTIFIABLEENCOUNTERS_FK1";


-- whoa, lets assign random uuids to MarkedIndividual!  welcome to the future.
--    (this will also bubble over to MARKEDINDIVIDUAL_ENCOUNTERS too)
UPDATE "MARKEDINDIVIDUAL" SET "INDIVIDUALID" = uuid_generate_v4();


-- now lets update other places that need to know our new ids
-- NOTE: these fields should probably (or are) be deprecated, in favor of propery obj reference
UPDATE "ENCOUNTER" AS b SET "INDIVIDUALID" = a."INDIVIDUALID" FROM "MARKEDINDIVIDUAL" AS a WHERE a."LEGACYINDIVIDUALID" = b."INDIVIDUALID";
UPDATE "ADOPTION" AS b SET "INDIVIDUAL" = a."INDIVIDUALID" FROM "MARKEDINDIVIDUAL" AS a WHERE a."LEGACYINDIVIDUALID" = b."INDIVIDUAL";

--- TODO migrate the old INDIVIDUALID and ALTERNATEID(s) TO NAMES (MultiValue) !!!!!!!!!!!!!!  FIXME
---  note: this is now done via appadmin/migrateMarkedIndividualNames.jsp



--update RELATIONSHIP to point instead to indiv uuids
UPDATE "RELATIONSHIP" AS b SET "MARKEDINDIVIDUALNAME1" = a."INDIVIDUALID" FROM "MARKEDINDIVIDUAL" AS a WHERE a."LEGACYINDIVIDUALID" = b."MARKEDINDIVIDUALNAME1";
UPDATE "RELATIONSHIP" AS b SET "MARKEDINDIVIDUALNAME2" = a."INDIVIDUALID" FROM "MARKEDINDIVIDUAL" AS a WHERE a."LEGACYINDIVIDUALID" = b."MARKEDINDIVIDUALNAME2";


-- cuz we probably should have these.
CREATE INDEX "RELATIONSHIP_MARKEDINDIVIDUALNAME1_idx" ON "RELATIONSHIP" ("MARKEDINDIVIDUALNAME1");
CREATE INDEX "RELATIONSHIP_MARKEDINDIVIDUALNAME2_idx" ON "RELATIONSHIP" ("MARKEDINDIVIDUALNAME2");
CREATE INDEX "RELATIONSHIP_MARKEDINDIVIDUALROLE1_idx" ON "RELATIONSHIP" ("MARKEDINDIVIDUALROLE1");
CREATE INDEX "RELATIONSHIP_MARKEDINDIVIDUALROLE2_idx" ON "RELATIONSHIP" ("MARKEDINDIVIDUALROLE2");
CREATE INDEX "RELATIONSHIP_TYPE_idx" ON "RELATIONSHIP" ("TYPE");



-- flukebook had a single RELATIONSHIP with an empty-string id in it, which fubared the constraints (below)
--  use this under your own discretion  etc.   (might want to do NULL as well?)
DELETE FROM "RELATIONSHIP" WHERE "MARKEDINDIVIDUALNAME1" = '' OR "MARKEDINDIVIDUALNAME2" ='';

-- these foreign key constraints would be nice, provided they dont fail.... sigh
ALTER TABLE "RELATIONSHIP" ADD CONSTRAINT "RELATIONSHIP_FK1" FOREIGN KEY ("MARKEDINDIVIDUALNAME1") REFERENCES "MARKEDINDIVIDUAL"("INDIVIDUALID") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "RELATIONSHIP" ADD CONSTRAINT "RELATIONSHIP_FK2" FOREIGN KEY ("MARKEDINDIVIDUALNAME2") REFERENCES "MARKEDINDIVIDUAL"("INDIVIDUALID") DEFERRABLE INITIALLY DEFERRED;


